{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\nimport { logChatPromiseExecution } from 'stream-chat';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nexport var useMessageInputText = function (props, state, dispatch) {\n  var channel = useChannelStateContext().channel;\n  var additionalTextareaProps = props.additionalTextareaProps,\n      focus = props.focus,\n      parent = props.parent,\n      publishTypingEvent = props.publishTypingEvent;\n  var text = state.text;\n  var textareaRef = useRef(); // Focus\n\n  useEffect(function () {\n    if (focus && textareaRef.current) {\n      textareaRef.current.focus();\n    }\n  }, [focus]); // Text + cursor position\n\n  var newCursorPosition = useRef();\n  var insertText = useCallback(function (textToInsert) {\n    var maxLength = (additionalTextareaProps || {}).maxLength;\n\n    if (!textareaRef.current) {\n      dispatch({\n        getNewText: function (text) {\n          var updatedText = text + textToInsert;\n\n          if (maxLength && updatedText.length > maxLength) {\n            return updatedText.slice(0, maxLength);\n          }\n\n          return updatedText;\n        },\n        type: 'setText'\n      });\n      return;\n    }\n\n    var _a = textareaRef.current,\n        selectionEnd = _a.selectionEnd,\n        selectionStart = _a.selectionStart;\n    newCursorPosition.current = selectionStart + textToInsert.length;\n    dispatch({\n      getNewText: function (prevText) {\n        var updatedText = prevText.slice(0, selectionStart) + textToInsert + prevText.slice(selectionEnd);\n\n        if (maxLength && updatedText.length > maxLength) {\n          return updatedText.slice(0, maxLength);\n        }\n\n        return updatedText;\n      },\n      type: 'setText'\n    });\n  }, [additionalTextareaProps, newCursorPosition, textareaRef]);\n  useEffect(function () {\n    var textareaElement = textareaRef.current;\n\n    if (textareaElement && newCursorPosition.current !== undefined) {\n      textareaElement.selectionStart = newCursorPosition.current;\n      textareaElement.selectionEnd = newCursorPosition.current;\n      newCursorPosition.current = undefined;\n    }\n  }, [text, newCursorPosition]);\n  var handleChange = useCallback(function (event) {\n    event.preventDefault();\n\n    if (!event || !event.target) {\n      return;\n    }\n\n    var newText = event.target.value;\n    dispatch({\n      getNewText: function () {\n        return newText;\n      },\n      type: 'setText'\n    });\n\n    if (publishTypingEvent && newText && channel) {\n      logChatPromiseExecution(channel.keystroke(parent === null || parent === void 0 ? void 0 : parent.id), 'start typing event');\n    }\n  }, [channel, parent, publishTypingEvent]);\n  return {\n    handleChange: handleChange,\n    insertText: insertText,\n    textareaRef: textareaRef\n  };\n};","map":{"version":3,"sources":["/Users/zeeshanpatel/flow/node_modules/stream-chat-react/dist/components/MessageInput/hooks/useMessageInputText.js"],"names":["useCallback","useEffect","useRef","logChatPromiseExecution","useChannelStateContext","useMessageInputText","props","state","dispatch","channel","additionalTextareaProps","focus","parent","publishTypingEvent","text","textareaRef","current","newCursorPosition","insertText","textToInsert","maxLength","getNewText","updatedText","length","slice","type","_a","selectionEnd","selectionStart","prevText","textareaElement","undefined","handleChange","event","preventDefault","target","newText","value","keystroke","id"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { logChatPromiseExecution } from 'stream-chat';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nexport var useMessageInputText = function (props, state, dispatch) {\n    var channel = useChannelStateContext().channel;\n    var additionalTextareaProps = props.additionalTextareaProps, focus = props.focus, parent = props.parent, publishTypingEvent = props.publishTypingEvent;\n    var text = state.text;\n    var textareaRef = useRef();\n    // Focus\n    useEffect(function () {\n        if (focus && textareaRef.current) {\n            textareaRef.current.focus();\n        }\n    }, [focus]);\n    // Text + cursor position\n    var newCursorPosition = useRef();\n    var insertText = useCallback(function (textToInsert) {\n        var maxLength = (additionalTextareaProps || {}).maxLength;\n        if (!textareaRef.current) {\n            dispatch({\n                getNewText: function (text) {\n                    var updatedText = text + textToInsert;\n                    if (maxLength && updatedText.length > maxLength) {\n                        return updatedText.slice(0, maxLength);\n                    }\n                    return updatedText;\n                },\n                type: 'setText',\n            });\n            return;\n        }\n        var _a = textareaRef.current, selectionEnd = _a.selectionEnd, selectionStart = _a.selectionStart;\n        newCursorPosition.current = selectionStart + textToInsert.length;\n        dispatch({\n            getNewText: function (prevText) {\n                var updatedText = prevText.slice(0, selectionStart) + textToInsert + prevText.slice(selectionEnd);\n                if (maxLength && updatedText.length > maxLength) {\n                    return updatedText.slice(0, maxLength);\n                }\n                return updatedText;\n            },\n            type: 'setText',\n        });\n    }, [additionalTextareaProps, newCursorPosition, textareaRef]);\n    useEffect(function () {\n        var textareaElement = textareaRef.current;\n        if (textareaElement && newCursorPosition.current !== undefined) {\n            textareaElement.selectionStart = newCursorPosition.current;\n            textareaElement.selectionEnd = newCursorPosition.current;\n            newCursorPosition.current = undefined;\n        }\n    }, [text, newCursorPosition]);\n    var handleChange = useCallback(function (event) {\n        event.preventDefault();\n        if (!event || !event.target) {\n            return;\n        }\n        var newText = event.target.value;\n        dispatch({\n            getNewText: function () { return newText; },\n            type: 'setText',\n        });\n        if (publishTypingEvent && newText && channel) {\n            logChatPromiseExecution(channel.keystroke(parent === null || parent === void 0 ? void 0 : parent.id), 'start typing event');\n        }\n    }, [channel, parent, publishTypingEvent]);\n    return {\n        handleChange: handleChange,\n        insertText: insertText,\n        textareaRef: textareaRef,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}