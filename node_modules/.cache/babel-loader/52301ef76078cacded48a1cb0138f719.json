{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nimport { useChannelActionContext } from '../../../context/ChannelActionContext';\nimport { logChatPromiseExecution } from 'stream-chat';\n/**\n * Get attachment type from MIME type\n */\n\nvar getAttachmentTypeFromMime = function (mime) {\n  if (mime.includes('video/')) return 'video';\n  if (mime.includes('audio/')) return 'audio';\n  return 'file';\n};\n\nexport var useSubmitHandler = function (props, state, dispatch, numberOfUploads) {\n  var clearEditingState = props.clearEditingState,\n      message = props.message,\n      overrideSubmitHandler = props.overrideSubmitHandler,\n      parent = props.parent,\n      publishTypingEvent = props.publishTypingEvent;\n  var attachments = state.attachments,\n      fileOrder = state.fileOrder,\n      fileUploads = state.fileUploads,\n      imageOrder = state.imageOrder,\n      imageUploads = state.imageUploads,\n      mentioned_users = state.mentioned_users,\n      text = state.text;\n  var channel = useChannelStateContext().channel;\n\n  var _a = useChannelActionContext(),\n      editMessage = _a.editMessage,\n      sendMessage = _a.sendMessage;\n\n  var getAttachmentsFromUploads = function () {\n    var imageAttachments = imageOrder.map(function (id) {\n      return imageUploads[id];\n    }).filter(function (upload) {\n      return upload.state !== 'failed';\n    }).filter(function (_a, _, self) {\n      var id = _a.id,\n          url = _a.url;\n      return self.every(function (upload) {\n        return upload.id === id || upload.url !== url;\n      });\n    }).map(function (upload) {\n      return {\n        fallback: upload.file.name,\n        image_url: upload.url,\n        type: 'image'\n      };\n    });\n    var fileAttachments = fileOrder.map(function (id) {\n      return fileUploads[id];\n    }).filter(function (upload) {\n      return upload.state !== 'failed';\n    }).map(function (upload) {\n      return {\n        asset_url: upload.url,\n        file_size: upload.file.size,\n        mime_type: upload.file.type,\n        title: upload.file.name,\n        type: getAttachmentTypeFromMime(upload.file.type || '')\n      };\n    });\n    return __spreadArray(__spreadArray(__spreadArray([], attachments), imageAttachments), fileAttachments);\n  };\n\n  var handleSubmit = function (event) {\n    event.preventDefault();\n    var trimmedMessage = text.trim();\n    var isEmptyMessage = trimmedMessage === '' || trimmedMessage === '>' || trimmedMessage === '``````' || trimmedMessage === '``' || trimmedMessage === '**' || trimmedMessage === '____' || trimmedMessage === '__' || trimmedMessage === '****';\n\n    if (isEmptyMessage && numberOfUploads === 0) {\n      return;\n    } // the channel component handles the actual sending of the message\n\n\n    var someAttachmentsUploading = Object.values(imageUploads).some(function (upload) {\n      return upload.state === 'uploading';\n    }) || Object.values(fileUploads).some(function (upload) {\n      return upload.state === 'uploading';\n    });\n\n    if (someAttachmentsUploading) {\n      // TODO: show error to user that they should wait until image is uploaded\n      return;\n    }\n\n    var newAttachments = getAttachmentsFromUploads(); // Instead of checking if a user is still mentioned every time the text changes,\n    // just filter out non-mentioned users before submit, which is cheaper\n    // and allows users to easily undo any accidental deletion\n\n    var actualMentionedUsers = Array.from(new Set(mentioned_users.filter(function (_a) {\n      var id = _a.id,\n          name = _a.name;\n      return text.includes(\"@\" + id) || text.includes(\"@\" + name);\n    })));\n    var updatedMessage = {\n      attachments: newAttachments,\n      mentioned_users: actualMentionedUsers,\n      text: text\n    };\n\n    if (!!message && editMessage) {\n      // TODO: Remove this line and show an error when submit fails\n      if (clearEditingState) {\n        clearEditingState();\n      }\n\n      var updateMessagePromise = editMessage(__assign(__assign({}, updatedMessage), {\n        id: message.id\n      })).then(clearEditingState);\n      logChatPromiseExecution(updateMessagePromise, 'update message');\n      dispatch({\n        type: 'clear'\n      });\n    } else if (overrideSubmitHandler) {\n      overrideSubmitHandler(__assign(__assign({}, updatedMessage), {\n        parent: parent\n      }), channel.cid);\n      dispatch({\n        type: 'clear'\n      });\n    } else if (sendMessage) {\n      var sendMessagePromise = sendMessage(__assign(__assign({}, updatedMessage), {\n        parent: parent\n      }));\n      logChatPromiseExecution(sendMessagePromise, 'send message');\n      dispatch({\n        type: 'clear'\n      });\n    }\n\n    if (publishTypingEvent) logChatPromiseExecution(channel.stopTyping(), 'stop typing');\n  };\n\n  return {\n    handleSubmit: handleSubmit\n  };\n};","map":{"version":3,"sources":["/Users/zeeshanpatel/flow/node_modules/stream-chat-react/dist/components/MessageInput/hooks/useSubmitHandler.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","il","j","useChannelStateContext","useChannelActionContext","logChatPromiseExecution","getAttachmentTypeFromMime","mime","includes","useSubmitHandler","props","state","dispatch","numberOfUploads","clearEditingState","message","overrideSubmitHandler","parent","publishTypingEvent","attachments","fileOrder","fileUploads","imageOrder","imageUploads","mentioned_users","text","channel","_a","editMessage","sendMessage","getAttachmentsFromUploads","imageAttachments","map","id","filter","upload","_","self","url","every","fallback","file","name","image_url","type","fileAttachments","asset_url","file_size","size","mime_type","title","handleSubmit","event","preventDefault","trimmedMessage","trim","isEmptyMessage","someAttachmentsUploading","values","some","newAttachments","actualMentionedUsers","Array","Set","updatedMessage","updateMessagePromise","then","cid","sendMessagePromise","stopTyping"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nimport { useChannelActionContext } from '../../../context/ChannelActionContext';\nimport { logChatPromiseExecution } from 'stream-chat';\n/**\n * Get attachment type from MIME type\n */\nvar getAttachmentTypeFromMime = function (mime) {\n    if (mime.includes('video/'))\n        return 'video';\n    if (mime.includes('audio/'))\n        return 'audio';\n    return 'file';\n};\nexport var useSubmitHandler = function (props, state, dispatch, numberOfUploads) {\n    var clearEditingState = props.clearEditingState, message = props.message, overrideSubmitHandler = props.overrideSubmitHandler, parent = props.parent, publishTypingEvent = props.publishTypingEvent;\n    var attachments = state.attachments, fileOrder = state.fileOrder, fileUploads = state.fileUploads, imageOrder = state.imageOrder, imageUploads = state.imageUploads, mentioned_users = state.mentioned_users, text = state.text;\n    var channel = useChannelStateContext().channel;\n    var _a = useChannelActionContext(), editMessage = _a.editMessage, sendMessage = _a.sendMessage;\n    var getAttachmentsFromUploads = function () {\n        var imageAttachments = imageOrder\n            .map(function (id) { return imageUploads[id]; })\n            .filter(function (upload) { return upload.state !== 'failed'; })\n            .filter(function (_a, _, self) {\n            var id = _a.id, url = _a.url;\n            return self.every(function (upload) { return upload.id === id || upload.url !== url; });\n        })\n            .map(function (upload) {\n            return ({\n                fallback: upload.file.name,\n                image_url: upload.url,\n                type: 'image',\n            });\n        });\n        var fileAttachments = fileOrder\n            .map(function (id) { return fileUploads[id]; })\n            .filter(function (upload) { return upload.state !== 'failed'; })\n            .map(function (upload) {\n            return ({\n                asset_url: upload.url,\n                file_size: upload.file.size,\n                mime_type: upload.file.type,\n                title: upload.file.name,\n                type: getAttachmentTypeFromMime(upload.file.type || ''),\n            });\n        });\n        return __spreadArray(__spreadArray(__spreadArray([], attachments), imageAttachments), fileAttachments);\n    };\n    var handleSubmit = function (event) {\n        event.preventDefault();\n        var trimmedMessage = text.trim();\n        var isEmptyMessage = trimmedMessage === '' ||\n            trimmedMessage === '>' ||\n            trimmedMessage === '``````' ||\n            trimmedMessage === '``' ||\n            trimmedMessage === '**' ||\n            trimmedMessage === '____' ||\n            trimmedMessage === '__' ||\n            trimmedMessage === '****';\n        if (isEmptyMessage && numberOfUploads === 0) {\n            return;\n        }\n        // the channel component handles the actual sending of the message\n        var someAttachmentsUploading = Object.values(imageUploads).some(function (upload) { return upload.state === 'uploading'; }) ||\n            Object.values(fileUploads).some(function (upload) { return upload.state === 'uploading'; });\n        if (someAttachmentsUploading) {\n            // TODO: show error to user that they should wait until image is uploaded\n            return;\n        }\n        var newAttachments = getAttachmentsFromUploads();\n        // Instead of checking if a user is still mentioned every time the text changes,\n        // just filter out non-mentioned users before submit, which is cheaper\n        // and allows users to easily undo any accidental deletion\n        var actualMentionedUsers = Array.from(new Set(mentioned_users.filter(function (_a) {\n            var id = _a.id, name = _a.name;\n            return text.includes(\"@\" + id) || text.includes(\"@\" + name);\n        })));\n        var updatedMessage = {\n            attachments: newAttachments,\n            mentioned_users: actualMentionedUsers,\n            text: text,\n        };\n        if (!!message && editMessage) {\n            // TODO: Remove this line and show an error when submit fails\n            if (clearEditingState) {\n                clearEditingState();\n            }\n            var updateMessagePromise = editMessage(__assign(__assign({}, updatedMessage), { id: message.id })).then(clearEditingState);\n            logChatPromiseExecution(updateMessagePromise, 'update message');\n            dispatch({ type: 'clear' });\n        }\n        else if (overrideSubmitHandler) {\n            overrideSubmitHandler(__assign(__assign({}, updatedMessage), { parent: parent }), channel.cid);\n            dispatch({ type: 'clear' });\n        }\n        else if (sendMessage) {\n            var sendMessagePromise = sendMessage(__assign(__assign({}, updatedMessage), { parent: parent }));\n            logChatPromiseExecution(sendMessagePromise, 'send message');\n            dispatch({ type: 'clear' });\n        }\n        if (publishTypingEvent)\n            logChatPromiseExecution(channel.stopTyping(), 'stop typing');\n    };\n    return {\n        handleSubmit: handleSubmit,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}